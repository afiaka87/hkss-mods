<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Graph Widget</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: transparent;
            font-family: 'Segoe UI', Arial, sans-serif;
            color: #fff;
            padding: 10px;
        }

        .container {
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid rgba(100, 150, 255, 0.4);
            border-radius: 8px;
            padding: 12px;
            width: 400px;
            height: 200px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .title {
            color: #88aaff;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stats {
            display: flex;
            gap: 15px;
            font-size: 12px;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #fff;
            font-weight: bold;
        }

        .fps-current {
            font-size: 18px;
            font-weight: bold;
        }

        .fps-good { color: #66ff66; }
        .fps-ok { color: #ffff66; }
        .fps-bad { color: #ff6666; }

        .graph-container {
            position: relative;
            height: 120px;
            background: rgba(20, 20, 30, 0.5);
            border: 1px solid rgba(100, 150, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .graph-labels {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .y-label {
            position: absolute;
            left: 2px;
            font-size: 9px;
            color: #666;
        }

        .target-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background: rgba(100, 255, 100, 0.3);
            border-top: 1px dashed rgba(100, 255, 100, 0.5);
        }

        .status {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #33ff33;
            box-shadow: 0 0 8px rgba(50, 255, 50, 0.8);
            animation: pulse 2s infinite;
        }

        .status.disconnected {
            background: #ff3333;
            box-shadow: 0 0 8px rgba(255, 50, 50, 0.8);
            animation: none;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="status" id="connectionStatus"></div>

        <div class="header">
            <div class="title">FPS Monitor</div>
            <div class="stats">
                <div>
                    <span class="stat-label">Current:</span>
                    <span class="stat-value fps-current" id="fpsCurrent">--</span>
                </div>
                <div>
                    <span class="stat-label">Avg:</span>
                    <span class="stat-value" id="fpsAvg">--</span>
                </div>
                <div>
                    <span class="stat-label">Min:</span>
                    <span class="stat-value" id="fpsMin">--</span>
                </div>
                <div>
                    <span class="stat-label">Max:</span>
                    <span class="stat-value" id="fpsMax">--</span>
                </div>
            </div>
        </div>

        <div class="graph-container">
            <canvas id="fpsCanvas"></canvas>
            <div class="graph-labels">
                <div class="y-label" style="top: 2px;">120</div>
                <div class="y-label" style="top: 30%;">60</div>
                <div class="y-label" style="top: 60%;">30</div>
                <div class="y-label" style="bottom: 2px;">0</div>
                <div class="target-line" style="top: 50%;"></div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const HTTP_URL = 'http://0.0.0.0:8080';
        const UPDATE_INTERVAL = 100; // Update every 100ms (10 Hz)
        const HISTORY_SECONDS = 30; // Show last 30 seconds
        const MAX_FPS = 120;
        const TARGET_FPS = 60;

        // Graph setup
        const canvas = document.getElementById('fpsCanvas');
        const ctx = canvas.getContext('2d');
        let canvasWidth, canvasHeight;

        // Data storage
        const fpsHistory = [];
        const maxDataPoints = (HISTORY_SECONDS * 1000) / UPDATE_INTERVAL;

        // Stats
        let isConnected = false;
        let isUpdating = false;

        // Elements
        const elements = {
            fpsCurrent: document.getElementById('fpsCurrent'),
            fpsAvg: document.getElementById('fpsAvg'),
            fpsMin: document.getElementById('fpsMin'),
            fpsMax: document.getElementById('fpsMax'),
            connectionStatus: document.getElementById('connectionStatus')
        };

        // Resize canvas for sharp rendering
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvasWidth = rect.width * window.devicePixelRatio;
            canvasHeight = rect.height * window.devicePixelRatio;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        // Update FPS color based on value
        function getFpsColor(fps) {
            if (fps >= 55) return 'fps-good';
            if (fps >= 30) return 'fps-ok';
            return 'fps-bad';
        }

        // Get graph color for FPS value
        function getGraphColor(fps) {
            if (fps >= 55) return '#66ff66';
            if (fps >= 30) return '#ffff66';
            return '#ff6666';
        }

        // Draw the FPS graph
        function drawGraph() {
            if (!ctx) return;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (fpsHistory.length < 2) return;

            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;
            const pointSpacing = width / maxDataPoints;

            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 4]);

            // Horizontal grid lines
            for (let i = 0; i <= 4; i++) {
                const y = (height / 4) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            ctx.setLineDash([]);

            // Draw FPS line with gradient fill
            if (fpsHistory.length > 0) {
                // Create gradient fill
                const gradient = ctx.createLinearGradient(0, height, 0, 0);
                gradient.addColorStop(0, 'rgba(100, 255, 100, 0.0)');
                gradient.addColorStop(0.5, 'rgba(100, 255, 100, 0.1)');
                gradient.addColorStop(1, 'rgba(100, 255, 100, 0.2)');

                // Draw filled area
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(0, height);

                for (let i = 0; i < fpsHistory.length; i++) {
                    const x = i * pointSpacing;
                    const fps = fpsHistory[i];
                    const y = height - (fps / MAX_FPS) * height;

                    if (i === 0) {
                        ctx.lineTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.lineTo((fpsHistory.length - 1) * pointSpacing, height);
                ctx.closePath();
                ctx.fill();

                // Draw the line
                ctx.strokeStyle = '#88ff88';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < fpsHistory.length; i++) {
                    const x = i * pointSpacing;
                    const fps = fpsHistory[i];
                    const y = height - (fps / MAX_FPS) * height;

                    // Change color based on FPS
                    const segmentColor = getGraphColor(fps);

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        // Draw segment with color
                        ctx.strokeStyle = segmentColor;
                        ctx.lineTo(x, y);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw points for last few values
                const pointsToShow = Math.min(10, fpsHistory.length);
                for (let i = fpsHistory.length - pointsToShow; i < fpsHistory.length; i++) {
                    const x = i * pointSpacing;
                    const fps = fpsHistory[i];
                    const y = height - (fps / MAX_FPS) * height;

                    ctx.fillStyle = getGraphColor(fps);
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw 60 FPS target line
            const targetY = height - (TARGET_FPS / MAX_FPS) * height;
            ctx.strokeStyle = 'rgba(100, 255, 100, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, targetY);
            ctx.lineTo(width, targetY);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Fetch and update data
        async function updateData() {
            if (isUpdating) return;
            isUpdating = true;

            try {
                const response = await fetch(`${HTTP_URL}/api/metrics?t=${Date.now()}`);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const metrics = await response.json();

                if (metrics && metrics.length > 0) {
                    // Find timing update with FPS
                    const timingUpdate = metrics.find(m => m.EventType === 'timing_update');

                    if (timingUpdate && timingUpdate.Data && timingUpdate.Data.fps) {
                        const fps = Math.round(timingUpdate.Data.fps);

                        // Add to history
                        fpsHistory.push(fps);
                        if (fpsHistory.length > maxDataPoints) {
                            fpsHistory.shift();
                        }

                        // Update current FPS
                        elements.fpsCurrent.textContent = fps;
                        elements.fpsCurrent.className = `stat-value fps-current ${getFpsColor(fps)}`;

                        // Calculate stats
                        if (fpsHistory.length > 0) {
                            const sum = fpsHistory.reduce((a, b) => a + b, 0);
                            const avg = Math.round(sum / fpsHistory.length);
                            const min = Math.min(...fpsHistory);
                            const max = Math.max(...fpsHistory);

                            elements.fpsAvg.textContent = avg;
                            elements.fpsMin.textContent = min;
                            elements.fpsMax.textContent = max;
                        }

                        // Update connection status
                        if (!isConnected) {
                            isConnected = true;
                            elements.connectionStatus.classList.remove('disconnected');
                        }

                        // Redraw graph
                        drawGraph();
                    }
                }
            } catch (error) {
                console.error('Update error:', error);
                if (isConnected) {
                    isConnected = false;
                    elements.connectionStatus.classList.add('disconnected');
                }
            } finally {
                isUpdating = false;
            }
        }

        // Initialize
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Start update loop
            setInterval(updateData, UPDATE_INTERVAL);
            updateData();
        }

        // Start
        init();
    </script>
</body>
</html>